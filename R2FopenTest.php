<?php

error_reporting(E_ALL);

require_once('vendor/autoload.php');

use Aws\S3\S3Client;
use PHPUnit\Framework\TestCase;
use Psr\Http\Message\RequestInterface;

/**
 * Configure using the following env vars:
 *
 *
 * BUCKET_NAME (Required)
 *
 *   The the script will create the relevant test files of appropriate sizes
 *   (they are small, less than 1MiB), and upload them.
 *   Ensure your PROFILE has write access in order to do this.
 *
 *
 * ENDPOINT_URL (Required)
 *
 *   This is a PoC relating to Cloudflare R2, which uses per-account URLs for
 *   R2 buckets.
 *
 *
 * PROFILE
 *
 *   Default: 'default'
 *
 *   Used to source credentials from your ~/.aws/credentials file.
 *
 *
 * REGION
 *
 *   Default: 'auto'
 *
 *   Given this PoC is about Cloudflare, this defaults to 'auto' as required
 *   by the R2 docs. However if you want to test AWS S3 or other providers,
 *   you will probably need to specify a region.
 *
 *
 * PROXY_URL
 *
 *   Default: empty
 *
 *   If you want to investigate further, you may need to MITM yourself in order
 *   to view the contents of the HTTPS requests. For example, using mitmproxy.
 *
 */
final class R2FopenTest extends TestCase {

    public function filesizes(): array {
        return [
            // [pow(2, 7)], // <- Expected to succeed
            // [pow(2, 8)], // <- Expected to succeed
            // [pow(2, 9)], // <- Expected to succeed
            // [pow(2, 15)], // <- Expected to succeed
            [pow(2, 16)], // <- Expected to FAIL approx 30% of the time.
            // [pow(2, 17)], // <- Expected to succeed
            // [pow(2, 23)], // <- Expected to succeed
            // [pow(2, 24)], // <- Expected to fail, but seemingly not quite as often as 2^16.
            // [pow(2, 25)], // <- Expected to succeed
        ];
    }

	private string $bucketName;

	private int $numAttempts = 10;

	private S3Client $client;

	/**
	 * @throws Exception If missing required env vars.
	 */
	public function setUp(): void {
		parent::setUp();

		$this->bucketName = getenv('BUCKET_NAME');

		if (!$this->bucketName) {
			throw new Exception("BUCKET_NAME env var not set.");
		}

		$endpoint = getenv('ENDPOINT_URL');
		if (!$endpoint) {
			throw new Exception("ENDPOINT_URL env var not set.");
		}

		$options = [
			'version' => 'latest',
			'endpoint' => $endpoint,
			'region' => getenv('REGION') ?: 'auto',
			'profile' => getenv('PROFILE') ?: 'default',
			// 'use_path_style_endpoint' => true,
		];

		$this->client = new S3Client($options);

	}

    /**
     * @dataProvider filesizes
     */	
    public function testFOpenReadingRangeWith20BytesBeforeAndNoBytesAfterPowerOf2($filesize) {
        $newSize = $filesize + 50;
		$this->runFOpenMultipeTimes($newSize, $filesize - 20, 20);
	}

    /**
     * @dataProvider filesizes
     */	
    public function testFOpenReadingRangeWith10BytesBeforeAnd10BytesAfterPowerOf2($filesize) {
        $newSize = $filesize + 50;
		$this->runFOpenMultipeTimes($newSize, $filesize - 10, 20);
	}

	private function runFOpenMultipeTimes(int $filesize, int $offset, int $count) {
		for ($i = 0; $i < $this->numAttempts; $i ++) {
			$string = $this->readUsingFOpen($filesize, $offset, $count);
			$this->assertEquals(
				$count,
				strlen($string),
				"Read incorrect number of bytes on attempt " . ($i + 1) . " of $this->numAttempts"
			);
		}
	}

	/*
	 * Commented out for now, because I can't manage to find a way to make this *fail*.
	 * Only fopen() fails at this point, and only with Cloudflare R2, not AWS S3.

	 public function testGuzzle() {
		for ($i = 0; $i < $this->numAttempts; $i ++) {
			$string = $this->readUsingGuzzle();
			$this->assertEquals(
				$this->bytesFromEnd,
				strlen($string),
				"Read incorrect number of bytes on attempt " . ($i + 1) . " of $this->numAttempts"
			);
		}
	}*/

    private $objectExistsCache = [];

    private function ensureExists(int $filesize) {
        if (isset($this->objectExistsCache["$filesize.txt"])) {
            return;
        }

		if (!$this->client->doesObjectExist($this->bucketName, "$filesize.txt")) {
			$this->client->putObject([
				'Bucket' => $this->bucketName,
				'Key' => "$filesize.txt",
				'Body' => self::generateRandomString($filesize),
			]);
		}

        $this->objectExistsCache["$filesize.txt"] = true;
    }

	private function createGetObjectRequest(int $filesize, int $offset, int $count): RequestInterface {
        $this->ensureExists($filesize);
		$end = $offset + $count;
		return \Aws\serialize(
			$this->client->getCommand('GetObject', [
				'Bucket' => $this->bucketName,
				'Key' => "$filesize.txt",
				'Range' => "bytes=$offset-$end",
			])
		);
	}

	private function createStreamContext(RequestInterface $request) {
		$headers = [];
		foreach ($request->getHeaders() as $name => $values) {
			$headers[] = "$name: $values[0]";
		}

		$opts = [
			'http' => [
				'protocol_version' => $request->getProtocolVersion(),
				'header' => $headers,
			],
		];

		$proxy = getenv('PROXY_URL') ?: null;
		if ($proxy) {
			$opts['http']['proxy'] = $proxy;
			$opts['http']['request_fulluri'] = true;
		}

		return stream_context_create($opts);
	}

	function readUsingFOpen(int $filesize, int $offset, int $count): string {
		$request = $this->createGetObjectRequest($filesize, $offset, $count);
		$context = $this->createStreamContext($request);
		$fh = fopen($request->getUri(), 'r', false, $context);
		return fread($fh, $count) ?: '';
	}

	function readUsingGuzzle(int $offset, int $count): string {
		$request = $this->createGetObjectRequest($offset, $count);
		$response = (new GuzzleHttp\Client())->sendRequest($request);
		return (string)$response->getBody();
	}

	private static function generateRandomString($length = 10): string {
		$characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
		$charactersLength = strlen($characters);
		$randomString = '';
		for ($i = 0; $i < $length; $i++) {
			$randomString .= $characters[rand(0, $charactersLength - 1)];
		}
		return $randomString;
	}

}
